The LangChain ecosystem:
The place where it all began, have been around for a long time 

Langraph:
Langraph is essentially built on top of LangChain. It uses LangChain's core building blocks (like chains, tools, memory, agents) and allows developers to compose and manage 
them visually using a graph editor.
- Langraph
- Langraph Studio
- Langraph Platform 


In LangGrapgh 

* Agent workflows are represented as GRAPHS
* State represents the current snapshot of the application. It is represented by an Annotation object.
* Nodes are python functions that represent agent logic. They receive the current state as input, do something and return the updated State. 
* Edges are also python functions that determine which Node to execute next based on the State. They can be conditional or Fixed. 

NODES DO THE WORK
EDGES CHOOSE WHAT TO DO NEXT. 
https://www.anthropic.com/engineering/building-effective-agents

Five steps to the first graph
1. Define the State class.
2. Start the Graph builder.
3. Create a Node
4. Create Edges
5. Compile the Graph 

SUPER STEP
In LangGraph, a super step is a key concept that refers to one full round of execution across the graph â€” it's how LangGraph processes your state through all active nodes.

Think of it Like This:
* Each node is a function or operation.
* The graph starts at the START node with some initial state (a dictionary-like object).
* During a super step:
  - Each node that is "active" receives the current state.
  - It performs its logic (e.g., calling an LLM, invoking a tool).
  - It returns a new state and possibly a signal about where to go next.
  - LangGraph then uses the returned state to decide which nodes to activate next.

When Would You Use Multiple Super Steps?
1. Dynamic workflows where the next node(s) to run depend on previous output.
2. Loops (e.g. the graph may revisit a node several times based on a condition).
3. Agent decision-making, where the graph might call tools iteratively.


